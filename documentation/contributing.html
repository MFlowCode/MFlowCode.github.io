<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SY496B9L99"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-SY496B9L99');
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MFC: Contributing</title>
<meta name=”keywords” content="exascale, fluid dynamics, cfd, computational fluid dynamics, compressible, hpc, bryngelson, colonius, subgrid, multiphase, frontier, summit, el capitan, aurora, amd gpu, gpu, nvidia"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
// This file is set as MATHJAX_CODEFILE in the Doxyfile. It configures how
// MathJax renders expressions in Markdown so that it is consistent with GitHub.
MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath:  [ ['$',  '$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true,
      ignoreClass: "line" // Ignore code blocks: https://web.archive.org/web/20120430100225/http://www.mathjax.org/docs/1.1/options/tex2jax.html
    },
    "HTML-CSS": {
      fonts: ["TeX"]
    }
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="icon.ico" type="image/x-icon" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MFC
   </div>
   <div id="projectbrief">Exascale flow solver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('contributing.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Contributing </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="autotoc_md65"></a>
Contributing to MFC</h1>
<p>We welcome contributions of all kinds: bug fixes, new features, documentation, tests, and issue triage. This guide covers everything you need to get started and get your changes merged.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md66"></a>
Getting Set Up</h2>
<ol type="1">
<li><b>Fork and clone</b> <div class="fragment"><div class="line">git clone https://github.com/&lt;your-user&gt;/MFC.git</div>
<div class="line">cd MFC</div>
<div class="line">git remote add upstream https://github.com/MFlowCode/MFC.git</div>
</div><!-- fragment --></li>
<li><b>Build MFC</b> (see <a class="el" href="getting-started.html" title="Getting Started">Getting Started</a> for full details): <div class="fragment"><div class="line">./mfc.sh build -j $(nproc)</div>
</div><!-- fragment --></li>
<li><b>Run the test suite</b> to verify your environment: <div class="fragment"><div class="line">./mfc.sh test -j $(nproc)</div>
</div><!-- fragment --></li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md67"></a>
Architecture Overview</h2>
<p>Understanding MFC's structure helps you know where to make changes and what they affect.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md68"></a>
Three-Phase Pipeline</h3>
<p>MFC runs simulations in three phases, each a separate Fortran executable:</p>
<ol type="1">
<li><b>pre_process</b> — Reads case parameters, generates initial conditions (patch geometries, flow states), writes binary grid and flow data to disk.</li>
<li><b>simulation</b> — Reads the initial state, advances the solution in time via TVD Runge-Kutta integration, writes solution snapshots at specified intervals.</li>
<li><b>post_process</b> — Reads simulation snapshots, computes derived quantities (vorticity, Schlieren, sound speed, etc.), writes Silo/HDF5 output for visualization.</li>
</ol>
<p>All three share code in <span class="tt">src/common/</span>. Only <span class="tt">simulation</span> is GPU-accelerated.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md69"></a>
Directory Layout</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Directory  </th><th class="markdownTableHeadNone">Contents  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">src/simulation/</span>  </td><td class="markdownTableBodyNone">Time-stepping, RHS, Riemann solvers, WENO, physics models (GPU-accelerated)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">src/pre_process/</span>  </td><td class="markdownTableBodyNone">Initial condition generation  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">src/post_process/</span>  </td><td class="markdownTableBodyNone">Derived variable computation and formatted output  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">src/common/</span>  </td><td class="markdownTableBodyNone">Derived types, global parameters, MPI, precision, I/O — shared by all three executables  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">toolchain/</span>  </td><td class="markdownTableBodyNone">Python CLI, parameter system, case validation, build orchestration  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">tests/</span>  </td><td class="markdownTableBodyNone">Golden files for 500+ regression tests  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">examples/</span>  </td><td class="markdownTableBodyNone">Sample case files  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">docs/</span>  </td><td class="markdownTableBodyNone">Doxygen documentation source  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="autotoc_md70"></a>
Simulation Data Flow</h3>
<p>Each time step, <span class="tt">simulation</span> computes the right-hand side through this pipeline:</p>
<div class="fragment"><div class="line">q_cons_vf (conservative variables: density, momentum, energy, volume fractions)</div>
<div class="line">    → convert to primitive (density, velocity, pressure)</div>
<div class="line">    → WENO reconstruction (left/right states at cell faces)</div>
<div class="line">    → Riemann solve (numerical fluxes)</div>
<div class="line">    → flux divergence + source terms (viscous, surface tension, body forces)</div>
<div class="line">    → RHS assembly</div>
<div class="line">    → Runge-Kutta update → q_cons_vf (next stage/step)</div>
</div><!-- fragment --><p>Key data structures (defined in <span class="tt">src/common/m_derived_types.fpp</span>):</p><ul>
<li><span class="tt">scalar_field</span> — wraps a 3D <span class="tt">real(stp)</span> array (<span class="tt">%sf(i,j,k)</span>)</li>
<li><span class="tt">vector_field</span> — array of <span class="tt">scalar_field</span> (<span class="tt">%vf(1:sys_size)</span>)</li>
<li><span class="tt">q_cons_vf</span> / <span class="tt">q_prim_vf</span> — conservative and primitive state vectors</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md71"></a>
Build Toolchain</h3>
<p><span class="tt">./mfc.sh</span> is a shell wrapper that invokes the Python toolchain (<span class="tt">toolchain/main.py</span>), which orchestrates:</p>
<ol type="1">
<li><b>CMake</b> configures the build (compiler detection, dependencies, GPU backend)</li>
<li><b>Fypp</b> preprocesses <span class="tt">.fpp</span> files into <span class="tt">.f90</span> (expands GPU macros, code generation)</li>
<li><b>Fortran compiler</b> builds three executables from the generated <span class="tt">.f90</span> files</li>
</ol>
<p>See <a class="el" href="parameters.html" title="Case Parameters">Case Parameters</a> for the full list of ~3,400 simulation parameters. See <a class="el" href="case_constraints.html" title="Case Creator Guide">Case Creator Guide</a> for feature compatibility and example configurations.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md72"></a>
Development Workflow</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Step  </th><th class="markdownTableHeadNone">Command / Action  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Sync your fork  </td><td class="markdownTableBodyNone"><span class="tt">git checkout master &amp;&amp; git pull upstream master</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Create a branch on your fork  </td><td class="markdownTableBodyNone"><span class="tt">git checkout -b feature/&lt;short-name&gt;</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Code, test, document  </td><td class="markdownTableBodyNone">Follow the standards below  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Run tests  </td><td class="markdownTableBodyNone"><span class="tt">./mfc.sh test</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Commit  </td><td class="markdownTableBodyNone">Clear, atomic commits (see below)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Push to your fork  </td><td class="markdownTableBodyNone"><span class="tt">git push origin feature/&lt;short-name&gt;</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Open a PR  </td><td class="markdownTableBodyNone">From your fork to <span class="tt">MFlowCode/MFC:master</span>. Every push triggers CI &ndash; bundle changes to avoid flooding the queue  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="autotoc_md73"></a>
Commit Messages</h3>
<ul>
<li>Start with a concise (50 chars or fewer) summary in imperative mood: <span class="tt">Fix out-of-bounds in EOS module</span></li>
<li>Add a blank line, then a detailed explanation if needed</li>
<li>Reference related issues: <span class="tt">Fixes #123</span> or <span class="tt">Part of #456</span></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md74"></a>
Coding Standards</h2>
<p>MFC is written in modern Fortran 2008+ with <a href="https://github.com/aradi/fypp">Fypp</a> metaprogramming. The standards below are split into <b>hard rules</b> (enforced in CI and review) and <b>soft guidelines</b> (goals for new code).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md75"></a>
Hard Rules</h3>
<p>These are enforced. CI and reviewers will flag violations.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Element  </th><th class="markdownTableHeadNone">Rule  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Formatting  </td><td class="markdownTableBodyNone">Enforced automatically by pre-commit hook (<span class="tt">./mfc.sh format</span> and <span class="tt">./mfc.sh lint</span>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Indentation  </td><td class="markdownTableBodyNone">2 spaces; continuation lines align beneath <span class="tt">&amp;</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Case  </td><td class="markdownTableBodyNone">Lowercase keywords and intrinsics (<span class="tt">do</span>, <span class="tt">end subroutine</span>, ...)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Modules  </td><td class="markdownTableBodyNone"><span class="tt">m_&lt;feature&gt;</span> (e.g. <span class="tt">m_riemann_solvers</span>)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Public subroutines  </td><td class="markdownTableBodyNone"><span class="tt">s_&lt;verb&gt;_&lt;noun&gt;</span> (e.g. <span class="tt">s_compute_flux</span>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Public functions  </td><td class="markdownTableBodyNone"><span class="tt">f_&lt;verb&gt;_&lt;noun&gt;</span> (e.g. <span class="tt">f_create_bbox</span>)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Variables  </td><td class="markdownTableBodyNone">Every argument has explicit <span class="tt">intent</span>; use <span class="tt">implicit none</span>, <span class="tt">dimension</span>/<span class="tt">allocatable</span>/<span class="tt">pointer</span> as appropriate  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Forbidden  </td><td class="markdownTableBodyNone"><span class="tt">goto</span>, <span class="tt">COMMON</span> blocks, global <span class="tt">save</span> variables  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error handling  </td><td class="markdownTableBodyNone">Call <span class="tt">s_mpi_abort(&lt;msg&gt;)</span> &ndash; never <span class="tt">stop</span> or <span class="tt">error stop</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GPU macros  </td><td class="markdownTableBodyNone">Do not use raw OpenACC/OpenMP pragmas. Use the project's Fypp GPU macros (see below)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Compiler support  </td><td class="markdownTableBodyNone">Code must compile with GNU gfortran, NVIDIA nvfortran, Cray ftn, and Intel ifx  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="autotoc_md76"></a>
Soft Guidelines</h3>
<p>Aim for these in new and modified code. Existing code may not meet all of them.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Element  </th><th class="markdownTableHeadNone">Guideline  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Routine size  </td><td class="markdownTableBodyNone">Prefer subroutine ≤ 500 lines, helper ≤ 150, function ≤ 100, file ≤ 1000  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Arguments  </td><td class="markdownTableBodyNone">Prefer ≤ 6; consider a derived-type params struct for more  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">DRY  </td><td class="markdownTableBodyNone">Avoid duplicating logic; factor shared code into helpers  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="autotoc_md77"></a>
Common Pitfalls</h2>
<p>This section documents domain-specific issues that frequently appear in MFC contributions. Both human reviewers and AI code reviewers reference this section.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md78"></a>
Array Bounds and Indexing</h3>
<ul>
<li>MFC uses <b>non-unity lower bounds</b> (e.g., <span class="tt">idwbuff(1)%beg:idwbuff(1)%end</span> with negative ghost-cell indices). Always verify loop bounds match array declarations.</li>
<li><b>Riemann solver indexing:</b> Left states at <span class="tt">j</span>, right states at <span class="tt">j+1</span>. Off-by-one here corrupts fluxes.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md79"></a>
Precision and Type Safety</h3>
<ul>
<li><b><span class="tt">stp</span> vs <span class="tt">wp</span> mixing:</b> In mixed-precision mode, <span class="tt">stp</span> (storage) may be half-precision while <span class="tt">wp</span> (working) is double. Conversions between them must be intentional, especially in MPI pack/unpack and RHS accumulation.</li>
<li><b>No double-precision intrinsics:</b> <span class="tt">dsqrt</span>, <span class="tt">dexp</span>, <span class="tt">dlog</span>, <span class="tt">dble</span>, <span class="tt">dabs</span>, <span class="tt">real(8)</span>, <span class="tt">real(4)</span> are forbidden. Use generic intrinsics with <span class="tt">wp</span> kind.</li>
<li><b>MPI type matching:</b> <span class="tt">mpi_p</span> must match <span class="tt">wp</span>; <span class="tt">mpi_io_p</span> must match <span class="tt">stp</span>. Mismatches corrupt communicated data.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md80"></a>
Memory and Allocation</h3>
<ul>
<li><b>ALLOCATE/DEALLOCATE pairing:</b> Every <span class="tt">@:ALLOCATE()</span> must have a matching <span class="tt">@:DEALLOCATE()</span>. Missing deallocations leak GPU memory.</li>
<li><b><span class="tt">@:ACC_SETUP_VFs</span> / <span class="tt">@:ACC_SETUP_SFs</span>:</b> Vector/scalar fields must have GPU pointer setup before use in kernels.</li>
<li><b>Conditional allocation:</b> If an array is allocated inside an <span class="tt">if</span> block, its deallocation must follow the same condition.</li>
<li><b>Out-of-bounds access:</b> Fortran is permissive with assumed-shape arrays. Check that index arithmetic stays within declared bounds.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md81"></a>
MPI Correctness</h3>
<ul>
<li><b>Halo exchange:</b> Pack/unpack offset calculations (<span class="tt">pack_offset</span>, <span class="tt">unpack_offset</span>) must be correct for both interior and periodic boundaries. Off-by-one causes data corruption.</li>
<li><b>GPU data coherence:</b> Non-RDMA MPI requires <span class="tt">GPU_UPDATE(host=...)</span> before send and <span class="tt">GPU_UPDATE(device=...)</span> after receive. Missing these causes stale data.</li>
<li><b>Buffer sizing:</b> <span class="tt">halo_size</span> depends on dimensionality and QBMM state. <span class="tt">v_size</span> must account for extra bubble variables when QBMM is active.</li>
<li><b>Deadlocks:</b> Mismatched send/recv counts or tags across MPI ranks.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md82"></a>
Physics and Model Consistency</h3>
<ul>
<li><b>Pressure formula</b> must match <span class="tt">model_eqns</span> value. Model 2/3 (multi-fluid), model 4 (bubbles), MHD, and hypoelastic each use different EOS formulations. Wrong formula = wrong physics.</li>
<li><b>Conservative-primitive conversion:</b> Density recovery, kinetic energy, and pressure each have model-specific paths. Verify the correct branch is taken.</li>
<li><b>Volume fractions</b> must sum to 1. <span class="tt">alpha_rho_K</span> must be non-negative. Species mass fractions should be clipped to [0,1].</li>
<li><b>Boundary conditions:</b> Periodic BCs must match at both ends (<span class="tt">bc_x%beg</span> and <span class="tt">bc_x%end</span>). Cylindrical coordinates have special requirements (<span class="tt">bc_y%beg = -14</span> for axis in 3D).</li>
<li><b>Parameter constraints:</b> New parameters or physics features must be validated in <span class="tt">toolchain/mfc/case_validator.py</span>. New features should add corresponding validation.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md83"></a>
Python Toolchain</h3>
<ul>
<li>New parameters in <span class="tt">toolchain/mfc/params/definitions.py</span> must have correct types, constraints, and tags.</li>
<li>Validation in <span class="tt">case_validator.py</span> must cover new interdependencies.</li>
<li>CLI schema in <span class="tt">toolchain/mfc/cli/commands.py</span> must match argument parsing.</li>
<li>Check subprocess calls for shell injection risks and missing error handling.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md84"></a>
Compiler Portability</h3>
<ul>
<li>Any compiler-specific code (<span class="tt">#ifdef __INTEL_COMPILER</span> etc.) must have fallbacks for all four supported compilers.</li>
<li>Fypp macros must expand correctly for both GPU and CPU builds (macros are <span class="tt">#ifdef</span>'d out for non-GPU).</li>
<li>No hardcoded GPU architectures without CMake detection.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md85"></a>
Architecture Notes</h3>
<ul>
<li><b><span class="tt">src/common/</span> affects all three executables</b> (pre_process, simulation, post_process). Changes here have wide blast radius.</li>
<li>No new global state; private helpers stay inside their defining module.</li>
<li>Flag modifications to public subroutine signatures, parameter defaults, or output formats.</li>
<li>Avoid unnecessary host/device transfers in hot loops, redundant allocations, and algorithmic inefficiency.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md86"></a>
Fypp and GPU</h2>
<p>MFC uses <a href="https://github.com/aradi/fypp">Fypp</a> macros (in <span class="tt">src/*/include/</span>) to generate accelerator-specific Fortran for OpenACC and OpenMP backends. Only <span class="tt">simulation</span> (plus its <span class="tt">common</span> dependencies) is GPU-accelerated.</p>
<ul>
<li><b>Raw OpenACC/OpenMP pragmas are not allowed.</b> Use the project's Fypp GPU macros instead.</li>
<li>Add <span class="tt">collapse(n)</span> when safe, declare loop-local variables with <span class="tt">private(...)</span>.</li>
<li>Avoid <span class="tt">stop</span>/<span class="tt">error stop</span> inside device code.</li>
<li>Keep macros simple and readable.</li>
</ul>
<p>See <a class="el" href="gpuParallelization.html" title="GPU Parallelization">GPU Parallelization</a> for the full GPU macro API reference, including all parameters, restrictions, examples, and debugging tools.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md87"></a>
How-To Guides</h2>
<p>Step-by-step recipes for common development tasks.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md88"></a>
How to Add a New Simulation Parameter</h3>
<p>Adding a parameter touches both the Python toolchain and Fortran source. Follow these steps in order. See <a class="el" href="parameters.html" title="Case Parameters">Case Parameters</a> for the full list of existing parameters and <a class="el" href="case_constraints.html" title="Case Creator Guide">Case Creator Guide</a> for feature compatibility.</p>
<p><b>Step 1: Register in Python</b> (<span class="tt">toolchain/mfc/params/definitions.py</span>)</p>
<p>Add a call to <span class="tt">_r()</span> inside the <span class="tt">_load()</span> function:</p>
<div class="fragment"><div class="line">_r(<span class="stringliteral">&quot;my_param&quot;</span>, REAL, {<span class="stringliteral">&quot;my_feature_tag&quot;</span>},</div>
<div class="line">   desc=<span class="stringliteral">&quot;Description of the parameter&quot;</span>,</div>
<div class="line">   math=<span class="stringliteral">r&quot;\f$\xi\f$&quot;</span>)</div>
</div><!-- fragment --><p>The arguments are:</p><ul>
<li><b>name</b>: parameter name (must match the Fortran namelist variable)</li>
<li><b>type</b>: <span class="tt">INT</span>, <span class="tt">REAL</span>, <span class="tt">LOG</span>, <span class="tt">STR</span>, or <span class="tt">A_REAL</span> (analytic expression)</li>
<li><b>tags</b>: set of feature tags for grouping (e.g. <span class="tt">{"bubbles"}</span>, <span class="tt">{"mhd"}</span>)</li>
<li><b>desc</b>: human-readable description (optional; auto-generated from <span class="tt">_SIMPLE_DESCS</span> or <span class="tt">_ATTR_DESCS</span> if omitted)</li>
<li><b>math</b>: LaTeX math symbol in Doxygen format (optional; shown in the Symbol column of <a class="el" href="parameters.html" title="Case Parameters">Case Parameters</a>)</li>
</ul>
<p>For indexed families like <span class="tt">fluid_pp</span>, put the symbol next to its attribute name using tuples:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> f <span class="keywordflow">in</span> range(1, NF + 1):</div>
<div class="line">    px = f<span class="stringliteral">&quot;fluid_pp({f})%&quot;</span></div>
<div class="line">    <span class="keywordflow">for</span> a, sym <span class="keywordflow">in</span> [(<span class="stringliteral">&quot;gamma&quot;</span>, <span class="stringliteral">r&quot;\f$\gamma_k\f$&quot;</span>),</div>
<div class="line">                   (<span class="stringliteral">&quot;my_attr&quot;</span>, <span class="stringliteral">r&quot;\f$\xi_k\f$&quot;</span>)]:  <span class="comment"># &lt;-- add here</span></div>
<div class="line">        _r(f<span class="stringliteral">&quot;{px}{a}&quot;</span>, REAL, math=sym)</div>
</div><!-- fragment --><p><b>Step 2: Add constraints</b> (same file, <span class="tt">CONSTRAINTS</span> dict)</p>
<p>If the parameter has valid ranges or choices:</p>
<div class="fragment"><div class="line">CONSTRAINTS = {</div>
<div class="line">    <span class="comment"># ...</span></div>
<div class="line">    <span class="stringliteral">&quot;my_param&quot;</span>: {<span class="stringliteral">&quot;min&quot;</span>: 0, <span class="stringliteral">&quot;max&quot;</span>: 100},</div>
<div class="line">    <span class="comment"># or: &quot;my_param&quot;: {&quot;choices&quot;: [1, 2, 3]},</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Step 3: Add dependencies</b> (same file, <span class="tt">DEPENDENCIES</span> dict)</p>
<p>If enabling one parameter requires or recommends others:</p>
<div class="fragment"><div class="line">DEPENDENCIES = {</div>
<div class="line">    <span class="comment"># ...</span></div>
<div class="line">    <span class="stringliteral">&quot;my_param&quot;</span>: {</div>
<div class="line">        <span class="stringliteral">&quot;when_true&quot;</span>: {</div>
<div class="line">            <span class="stringliteral">&quot;requires&quot;</span>: [<span class="stringliteral">&quot;other_param&quot;</span>],</div>
<div class="line">            <span class="stringliteral">&quot;recommends&quot;</span>: [<span class="stringliteral">&quot;optional_param&quot;</span>],</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line">}</div>
</div><!-- fragment --><p>Triggers include <span class="tt">when_true</span> (logical is <span class="tt">T</span>), <span class="tt">when_set</span> (parameter is not <span class="tt">None</span>), and <span class="tt">when_value</span> (parameter equals a specific value).</p>
<p><b>Step 4: Add physics validation</b> (<span class="tt">toolchain/mfc/case_validator.py</span>)</p>
<p>If the parameter has cross-parameter constraints that go beyond simple min/max:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>check_my_feature(self):</div>
<div class="line">    <span class="keywordflow">if</span> self.params[<span class="stringliteral">&quot;my_param&quot;</span>] &gt; 0 <span class="keywordflow">and</span> <span class="keywordflow">not</span> self.params[<span class="stringliteral">&quot;other_param&quot;</span>]:</div>
<div class="line">        self.errors.append(<span class="stringliteral">&quot;my_param requires other_param to be set&quot;</span>)</div>
</div><!-- fragment --><p>If your check enforces a physics constraint, also add a <span class="tt">PHYSICS_DOCS</span> entry (see <a class="el" href="#how-to-document-physics-constraints" title="How to Document Physics Constraints">How to Document Physics Constraints</a> below).</p>
<p><b>Step 5: Declare in Fortran</b> (<span class="tt">src/&lt;target&gt;/m_global_parameters.fpp</span>)</p>
<p>Add the variable declaration in the appropriate target's global parameters module. Choose the target(s) where the parameter is used:</p>
<ul>
<li><span class="tt">src/pre_process/m_global_parameters.fpp</span></li>
<li><span class="tt">src/simulation/m_global_parameters.fpp</span></li>
<li><span class="tt">src/post_process/m_global_parameters.fpp</span></li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">real</span>(wp) :: my_param<span class="comment">    !&lt; Description of the parameter</span></div>
</div><!-- fragment --><p>If the parameter is used in GPU kernels, add a GPU declaration:</p>
<div class="fragment"><div class="line">$:gpu_declare(create=<span class="stringliteral">&#39;[my_param]&#39;</span>)</div>
</div><!-- fragment --><p><b>Step 6: Add to Fortran namelist</b> (<span class="tt">src/&lt;target&gt;/m_start_up.fpp</span>)</p>
<p>Add the parameter name to the <span class="tt">namelist /user_inputs/</span> declaration:</p>
<div class="fragment"><div class="line">namelist /user_inputs/ ... , my_param, ...</div>
</div><!-- fragment --><p>The toolchain writes the parameter to the input file and Fortran reads it via this namelist. No other I/O code is needed.</p>
<p><b>Step 7: Use in Fortran code</b></p>
<p>Reference <span class="tt">my_param</span> anywhere in the target's modules. It is available as a global after the namelist is read at startup.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md89"></a>
How to Write a GPU Parallel Loop</h3>
<p>All GPU loops use Fypp macros. See <a class="el" href="gpuParallelization.html" title="GPU Parallelization">GPU Parallelization</a> for the full API.</p>
<p><b>Simple parallel loop</b> (3D with collapse):</p>
<div class="fragment"><div class="line">$:gpu_parallel_loop(collapse=3)</div>
<div class="line"><span class="keywordflow">do</span> l = 0, p</div>
<div class="line">    <span class="keywordflow">do</span> k = 0, n</div>
<div class="line">        <span class="keywordflow">do</span> j = 0, m</div>
<div class="line">            q_sf(j, k, l) = 0._wp</div>
<div class="line"><span class="keywordflow">        end do</span></div>
<div class="line"><span class="keywordflow">    end do</span></div>
<div class="line"><span class="keywordflow">end do</span></div>
<div class="line">$:end_gpu_parallel_loop()</div>
</div><!-- fragment --><p><b>With private variables</b> (temporaries local to each thread):</p>
<div class="fragment"><div class="line">$:gpu_parallel_loop(collapse=3, <span class="keywordtype">private</span>=<span class="stringliteral">&#39;[rho, pres, vel]&#39;</span>)</div>
<div class="line"><span class="keywordflow">do</span> l = 0, p</div>
<div class="line">    <span class="keywordflow">do</span> k = 0, n</div>
<div class="line">        <span class="keywordflow">do</span> j = 0, m</div>
<div class="line">            rho = q_prim_vf(1)%sf(j, k, l)</div>
<div class="line">            pres = q_prim_vf(e_idx)%sf(j, k, l)</div>
<div class="line">            <span class="comment">! ... use rho, pres as thread-local ...</span></div>
<div class="line"><span class="keywordflow">        end do</span></div>
<div class="line"><span class="keywordflow">    end do</span></div>
<div class="line"><span class="keywordflow">end do</span></div>
<div class="line">$:end_gpu_parallel_loop()</div>
</div><!-- fragment --><p><b>With reduction:</b></p>
<div class="fragment"><div class="line">$:gpu_parallel_loop(collapse=3, &amp;</div>
<div class="line">    &amp; reduction=<span class="stringliteral">&#39;[[my_sum], [my_max]]&#39;</span>, &amp;</div>
<div class="line">    &amp; reductionop=<span class="stringliteral">&#39;[+, MAX]&#39;</span>, &amp;</div>
<div class="line">    &amp; copy=<span class="stringliteral">&#39;[my_sum, my_max]&#39;</span>)</div>
<div class="line"><span class="keywordflow">do</span> l = 0, p</div>
<div class="line">    <span class="keywordflow">do</span> k = 0, n</div>
<div class="line">        <span class="keywordflow">do</span> j = 0, m</div>
<div class="line">            my_sum = my_sum + q_sf(j, k, l)</div>
<div class="line">            my_max = max(my_max, q_sf(j, k, l))</div>
<div class="line"><span class="keywordflow">        end do</span></div>
<div class="line"><span class="keywordflow">    end do</span></div>
<div class="line"><span class="keywordflow">end do</span></div>
<div class="line">$:end_gpu_parallel_loop()</div>
</div><!-- fragment --><p><b>Sequential inner loop</b> within a parallel region:</p>
<div class="fragment"><div class="line">$:gpu_parallel_loop(collapse=3)</div>
<div class="line"><span class="keywordflow">do</span> l = 0, p</div>
<div class="line">    <span class="keywordflow">do</span> k = 0, n</div>
<div class="line">        <span class="keywordflow">do</span> j = 0, m</div>
<div class="line">            $:gpu_loop(parallelism=<span class="stringliteral">&#39;[seq]&#39;</span>)</div>
<div class="line">            <span class="keywordflow">do</span> i = 1, num_fluids</div>
<div class="line">                alpha(i) = q_prim_vf(advxb + i - 1)%sf(j, k, l)</div>
<div class="line"><span class="keywordflow">            end do</span></div>
<div class="line"><span class="keywordflow">        end do</span></div>
<div class="line"><span class="keywordflow">    end do</span></div>
<div class="line"><span class="keywordflow">end do</span></div>
<div class="line">$:end_gpu_parallel_loop()</div>
</div><!-- fragment --><p>Key rules:</p><ul>
<li>Always pair <span class="tt">$:GPU_PARALLEL_LOOP(...)</span> with <span class="tt">$:END_GPU_PARALLEL_LOOP()</span></li>
<li>Use <span class="tt">collapse(n)</span> to fuse nested loops when the loop bounds are independent</li>
<li>Declare all loop-local temporaries in <span class="tt">private='[...]'</span></li>
<li>Never use <span class="tt">stop</span> or <span class="tt">error stop</span> inside a GPU loop</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md90"></a>
How to Allocate and Manage GPU Arrays</h3>
<p>The full lifecycle of a GPU-resident array:</p>
<p><b>Step 1: Declare</b> with GPU directive for module-level variables:</p>
<div class="fragment"><div class="line"><span class="keywordtype">real</span>(wp), <span class="keywordtype">allocatable</span>, <span class="keywordtype">dimension(:,:,:)</span> :: my_array</div>
<div class="line">$:gpu_declare(create=<span class="stringliteral">&#39;[my_array]&#39;</span>)</div>
</div><!-- fragment --><p><b>Step 2: Allocate</b> in your initialization subroutine:</p>
<div class="fragment"><div class="line">@:<span class="keyword">ALLOCATE</span>(my_array(0:m, 0:n, 0:p))</div>
</div><!-- fragment --><p><span class="tt">@:ALLOCATE</span> handles both the Fortran <span class="tt">allocate</span> and the GPU <span class="tt">enter data create</span>.</p>
<p><b>Step 3: Setup pointer fields</b> (only needed for derived types with pointer components like <span class="tt">scalar_field</span>):</p>
<div class="fragment"><div class="line">@:<span class="keyword">ALLOCATE</span>(my_field%sf(0:m, 0:n, 0:p))</div>
<div class="line">@:acc_setup_sfs(my_field)</div>
</div><!-- fragment --><p><span class="tt">@:ACC_SETUP_SFs</span> registers the pointer with the GPU runtime (required on Cray).</p>
<p><b>Step 4: Deallocate</b> in your finalization subroutine, mirroring every allocation:</p>
<div class="fragment"><div class="line">@:<span class="keyword">DEALLOCATE</span>(my_array)</div>
</div><!-- fragment --><p>If an array is allocated inside an <span class="tt">if</span> block, its deallocation must follow the same condition.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md91"></a>
How to Add a Test Case</h3>
<p><b>Step 1: Create a case file</b></p>
<p>Test cases are Python scripts that print a JSON dict of parameters. See <span class="tt">examples/</span> for templates:</p>
<div class="fragment"><div class="line"><span class="comment">#!/usr/bin/env python3</span></div>
<div class="line"><span class="keyword">import</span> json</div>
<div class="line"> </div>
<div class="line">print(json.dumps({</div>
<div class="line">    <span class="stringliteral">&quot;run_time_info&quot;</span>: <span class="stringliteral">&quot;F&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;x_domain%beg&quot;</span>: 0.0,</div>
<div class="line">    <span class="stringliteral">&quot;x_domain%end&quot;</span>: 1.0,</div>
<div class="line">    <span class="stringliteral">&quot;m&quot;</span>: 49,</div>
<div class="line">    <span class="stringliteral">&quot;n&quot;</span>: 0,</div>
<div class="line">    <span class="stringliteral">&quot;p&quot;</span>: 0,</div>
<div class="line">    <span class="stringliteral">&quot;dt&quot;</span>: 1e-6,</div>
<div class="line">    <span class="stringliteral">&quot;t_step_start&quot;</span>: 0,</div>
<div class="line">    <span class="stringliteral">&quot;t_step_stop&quot;</span>: 100,</div>
<div class="line">    <span class="stringliteral">&quot;t_step_save&quot;</span>: 100,</div>
<div class="line">    <span class="stringliteral">&quot;num_patches&quot;</span>: 1,</div>
<div class="line">    <span class="stringliteral">&quot;model_eqns&quot;</span>: 2,</div>
<div class="line">    <span class="stringliteral">&quot;num_fluids&quot;</span>: 1,</div>
<div class="line">    <span class="stringliteral">&quot;time_stepper&quot;</span>: 3,</div>
<div class="line">    <span class="stringliteral">&quot;weno_order&quot;</span>: 5,</div>
<div class="line">    <span class="stringliteral">&quot;riemann_solver&quot;</span>: 1,</div>
<div class="line">    <span class="stringliteral">&quot;patch_icpp(1)%geometry&quot;</span>: 1,</div>
<div class="line">    <span class="stringliteral">&quot;patch_icpp(1)%x_centroid&quot;</span>: 0.5,</div>
<div class="line">    <span class="stringliteral">&quot;patch_icpp(1)%length_x&quot;</span>: 1.0,</div>
<div class="line">    <span class="stringliteral">&quot;patch_icpp(1)%vel(1)&quot;</span>: 0.0,</div>
<div class="line">    <span class="stringliteral">&quot;patch_icpp(1)%pres&quot;</span>: 1.0,</div>
<div class="line">    <span class="stringliteral">&quot;patch_icpp(1)%alpha_rho(1)&quot;</span>: 1.0,</div>
<div class="line">    <span class="stringliteral">&quot;patch_icpp(1)%alpha(1)&quot;</span>: 1.0,</div>
<div class="line">    <span class="stringliteral">&quot;fluid_pp(1)%gamma&quot;</span>: 0.4,</div>
<div class="line">    <span class="stringliteral">&quot;fluid_pp(1)%pi_inf&quot;</span>: 0.0,</div>
<div class="line">}))</div>
</div><!-- fragment --><p>Keep grids small and runtimes short.</p>
<p><b>Step 2: Register as a regression test</b> (<span class="tt">toolchain/mfc/test/cases.py</span>)</p>
<p>Add your case using the <span class="tt">Case</span> dataclass and the stack pattern for parameterized variations:</p>
<div class="fragment"><div class="line">stack.push(<span class="stringliteral">&quot;my_feature&quot;</span>, {<span class="stringliteral">&quot;my_param&quot;</span>: value})</div>
<div class="line">cases.append(define_case_d(stack, <span class="stringliteral">&#39;&#39;</span>, {}))</div>
<div class="line">stack.pop()</div>
</div><!-- fragment --><p><b>Step 3: Generate golden files</b></p>
<div class="fragment"><div class="line">./mfc.sh test --generate -o &lt;test_id&gt;</div>
</div><!-- fragment --><p>Golden files are stored as binary snapshots in <span class="tt">tests/&lt;hash&gt;/</span>.</p>
<p><b>Step 4: Run</b></p>
<div class="fragment"><div class="line">./mfc.sh test -j $(nproc)</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md92"></a>
How to Create a New Fortran Module</h3>
<p><b>Step 1: Create the file</b></p>
<p>Name it <span class="tt">src/&lt;target&gt;/m_&lt;feature&gt;.fpp</span>. CMake auto-discovers <span class="tt">.fpp</span> files — no build system changes needed.</p>
<p><b>Step 2: Use this boilerplate:</b></p>
<div class="fragment"><div class="line"><span class="comment">!&gt; @file m_my_feature.fpp</span></div>
<div class="line"><span class="comment">!! @brief Description of the module</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#:include &#39;case.fpp&#39;</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#:include &#39;macros.fpp&#39;</span></div>
<div class="line"><span class="preprocessor"></span> </div>
<div class="line"><span class="keyword">module</span> m_my_feature</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">use </span>m_derived_types</div>
<div class="line">    <span class="keywordtype">use </span>m_global_parameters</div>
<div class="line">    <span class="keywordtype">use </span>m_mpi_proxy</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">implicit none</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">private</span>; <span class="keywordtype">public</span> :: s_initialize_my_feature, &amp;</div>
<div class="line">                       s_compute_my_feature, &amp;</div>
<div class="line">                       s_finalize_my_feature</div>
<div class="line"> </div>
<div class="line">    <span class="comment">! Module-level data</span></div>
<div class="line"><span class="keywordtype">    real</span>(wp), <span class="keywordtype">allocatable</span>, <span class="keywordtype">dimension(:,:,:)</span> :: work_array</div>
<div class="line"> </div>
<div class="line"><span class="keyword">contains</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    !&gt; Initialize module data</span></div>
<div class="line">    <span class="keywordtype">impure</span> <span class="keyword">subroutine </span>s_initialize_my_feature()</div>
<div class="line">        @:<span class="keyword">ALLOCATE</span>(work_array(0:m, 0:n, 0:p))</div>
<div class="line">    <span class="keyword">end subroutine </span>s_initialize_my_feature</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    !&gt; Core computation</span></div>
<div class="line">    <span class="keyword">subroutine </span>s_compute_my_feature(q_prim_vf, rhs_vf)</div>
<div class="line">        <span class="keywordtype">type</span>(scalar_field), <span class="keywordtype">dimension(sys_size)</span>, <span class="keywordtype">intent(in)</span> :: q_prim_vf</div>
<div class="line">        <span class="keywordtype">type</span>(scalar_field), <span class="keywordtype">dimension(sys_size)</span>, <span class="keywordtype">intent(inout)</span> :: rhs_vf</div>
<div class="line">        <span class="comment">! ...</span></div>
<div class="line">    <span class="keyword">end subroutine </span>s_compute_my_feature</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    !&gt; Clean up module data</span></div>
<div class="line">    <span class="keywordtype">impure</span> <span class="keyword">subroutine </span>s_finalize_my_feature()</div>
<div class="line">        @:<span class="keyword">DEALLOCATE</span>(work_array)</div>
<div class="line">    <span class="keyword">end subroutine </span>s_finalize_my_feature</div>
<div class="line"> </div>
<div class="line"><span class="keyword">end module </span>m_my_feature</div>
</div><!-- fragment --><p>Key conventions:</p><ul>
<li><span class="tt">private</span> by default, explicitly <span class="tt">public</span> for the module API</li>
<li>Initialize/finalize subroutines for allocation lifecycle</li>
<li>Every <span class="tt">@:ALLOCATE</span> has a matching <span class="tt">@:DEALLOCATE</span></li>
<li>Every argument has explicit <span class="tt">intent</span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md93"></a>
Working with the Precision System</h3>
<p>MFC supports double (default), single, and mixed precision. The types are defined in <span class="tt">src/common/m_precision_select.f90</span>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type  </th><th class="markdownTableHeadNone">Purpose  </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">wp</span>  </td><td class="markdownTableBodyNone">Working precision (computation)  </td><td class="markdownTableBodyNone"><span class="tt">real(wp) :: velocity</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">stp</span>  </td><td class="markdownTableBodyNone">Storage precision (I/O, field storage)  </td><td class="markdownTableBodyNone"><span class="tt">real(stp), pointer :: sf(:,:,:)</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">mpi_p</span>  </td><td class="markdownTableBodyNone">MPI type matching <span class="tt">wp</span>  </td><td class="markdownTableBodyNone"><span class="tt">call MPI_BCAST(var, 1, mpi_p, ...)</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">mpi_io_p</span>  </td><td class="markdownTableBodyNone">MPI type matching <span class="tt">stp</span>  </td><td class="markdownTableBodyNone">Used in parallel I/O  </td></tr>
</table>
<p>Rules:</p><ul>
<li>Use <span class="tt">real(wp)</span> for all computational variables</li>
<li>Literal constants need the <span class="tt">_wp</span> suffix: <span class="tt">1.0_wp</span>, <span class="tt">3.14159_wp</span>, <span class="tt">1e-6_wp</span></li>
<li>Use <b>generic</b> intrinsics only: <span class="tt">sqrt</span>, <span class="tt">abs</span>, <span class="tt">sin</span>, <span class="tt">exp</span>, <span class="tt">log</span>, <span class="tt">max</span>, <span class="tt">min</span></li>
<li><b>Forbidden</b> double-precision intrinsics: <span class="tt">dsqrt</span>, <span class="tt">dexp</span>, <span class="tt">dlog</span>, <span class="tt">dble</span>, <span class="tt">dabs</span>, <span class="tt">real(8)</span>, <span class="tt">real(4)</span></li>
<li>Conversions between <span class="tt">stp</span> and <span class="tt">wp</span> must be intentional, especially in MPI pack/unpack</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md94"></a>
How to Extend MPI Halo Exchange</h3>
<p>Halo exchange is in <span class="tt">src/simulation/m_mpi_proxy.fpp</span> (and <span class="tt">src/common/m_mpi_common.fpp</span> for buffer allocation).</p>
<p>To add new data to the halo exchange:</p>
<p><b>Step 1: Update buffer sizing</b> (<span class="tt">src/common/m_mpi_common.fpp</span>)</p>
<p><span class="tt">v_size</span> determines how many variables are packed per cell. If your new data adds fields per cell, increase <span class="tt">v_size</span>:</p>
<div class="fragment"><div class="line">v_size = sys_size + my_extra_fields</div>
</div><!-- fragment --><p><b>Step 2: Add pack loop</b> (<span class="tt">src/simulation/m_mpi_proxy.fpp</span>)</p>
<p>Pack your data into the send buffer using a linear index:</p>
<div class="fragment"><div class="line">$:gpu_parallel_loop(collapse=3, <span class="keywordtype">private</span>=<span class="stringliteral">&#39;[j,k,l,r]&#39;</span>)</div>
<div class="line"><span class="keywordflow">do</span> l = 0, p</div>
<div class="line">    <span class="keywordflow">do</span> k = 0, n</div>
<div class="line">        <span class="keywordflow">do</span> j = 0, buff_size - 1</div>
<div class="line">            r = j + buff_size*(k + (n + 1)*l)</div>
<div class="line">            buff_send(r) = my_data%sf(j + pack_offset, k, l)</div>
<div class="line"><span class="keywordflow">        end do</span></div>
<div class="line"><span class="keywordflow">    end do</span></div>
<div class="line"><span class="keywordflow">end do</span></div>
<div class="line">$:end_gpu_parallel_loop()</div>
</div><!-- fragment --><p><b>Step 3: GPU data coherence</b></p>
<p>For non-RDMA MPI, add host/device transfers around the MPI call:</p>
<div class="fragment"><div class="line">$:gpu_update(host=<span class="stringliteral">&#39;[buff_send]&#39;</span>)       <span class="comment">! GPU → CPU before send</span></div>
<div class="line"><span class="keyword">call </span>mpi_sendrecv(buff_send, ..., buff_recv, ..., ierr)</div>
<div class="line">$:gpu_update(device=<span class="stringliteral">&#39;[buff_recv]&#39;</span>)     ! cpu → gpu after receive</div>
</div><!-- fragment --><p><b>Step 4: Add unpack loop</b> mirroring the pack loop with <span class="tt">unpack_offset</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md95"></a>
How to Add a Post-Processing Output Variable</h3>
<p>Post-processing derived variables live in <span class="tt">src/post_process/m_derived_variables.fpp</span>.</p>
<p><b>Step 1: Allocate storage</b> in <span class="tt">s_initialize_derived_variables_module</span>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (my_var_wrt) <span class="keywordflow">then</span></div>
<div class="line">    <span class="keyword">allocate</span>(my_var_sf(-offset_x%beg:m + offset_x%end, &amp;</div>
<div class="line">                       -offset_y%beg:n + offset_y%end, &amp;</div>
<div class="line">                       -offset_z%beg:p + offset_z%end))</div>
<div class="line"><span class="keyword">end </span>if</div>
</div><!-- fragment --><p><b>Step 2: Create derivation subroutine:</b></p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>s_derive_my_variable(q_prim_vf, q_sf)</div>
<div class="line">    <span class="keywordtype">type</span>(scalar_field), <span class="keywordtype">dimension(sys_size)</span>, <span class="keywordtype">intent(in)</span> :: q_prim_vf</div>
<div class="line"><span class="keywordtype">    real</span>(wp), <span class="keywordtype">dimension(-offset_x%beg:m + offset_x%end, &amp;
                        -offset_y%beg:n + offset_y%end, &amp;
                        -offset_z%beg:p + offset_z%end)</span>, &amp;</div>
<div class="line">        <span class="keywordtype">intent(inout)</span> :: q_sf</div>
<div class="line">    <span class="keywordtype">integer</span> :: i, j, k</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span> k = -offset_z%beg, p + offset_z%end</div>
<div class="line">        <span class="keywordflow">do</span> j = -offset_y%beg, n + offset_y%end</div>
<div class="line">            <span class="keywordflow">do</span> i = -offset_x%beg, m + offset_x%end</div>
<div class="line">                q_sf(i, j, k) = <span class="comment">! ... compute from q_prim_vf ...</span></div>
<div class="line"><span class="keywordflow">            end do</span></div>
<div class="line"><span class="keywordflow">        end do</span></div>
<div class="line"><span class="keywordflow">    end do</span></div>
<div class="line"><span class="keyword">end subroutine </span>s_derive_my_variable</div>
</div><!-- fragment --><p><b>Step 3: Call from output</b> in <span class="tt">m_data_output.fpp</span>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (my_var_wrt) <span class="keywordflow">then</span></div>
<div class="line">    <span class="keyword">call </span>s_derive_my_variable(q_prim_vf, q_sf)</div>
<div class="line">    <span class="keyword">call </span>s_write_variable_to_formatted_database_file(q_sf, <span class="stringliteral">&#39;my_variable&#39;</span>, dbfile, dbroot)</div>
<div class="line"><span class="keyword">end </span>if</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md96"></a>
Modifying <span class="tt">src/common/</span></h3>
<p>Code in <span class="tt">src/common/</span> is compiled into all three executables (pre_process, simulation, post_process). Changes here have wide blast radius.</p>
<p>Checklist:</p><ul>
<li>Test all three targets: <span class="tt">./mfc.sh test</span> covers this</li>
<li>If adding GPU code, remember that only <span class="tt">simulation</span> is GPU-accelerated. Guard GPU macros with <span class="tt">#:if MFC_SIMULATION</span></li>
<li>Check that new <span class="tt">use</span> statements don't create circular dependencies</li>
<li>New modules need <span class="tt">implicit none</span> and explicit <span class="tt">intent</span> on all arguments</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md97"></a>
Debugging</h3>
<p>See <a class="el" href="troubleshooting.html" title="Troubleshooting Guide">Troubleshooting Guide</a> for debugging workflows, profiling tools, GPU diagnostic environment variables, common build/runtime errors, and fixes.</p>
<h3 class="doxsection"><a class="anchor" id="how-to-document-physics-constraints"></a>
How to Document Physics Constraints</h3>
<p>When adding a new <span class="tt">check_</span> method to <span class="tt">case_validator.py</span>, document its physics by adding an entry to the <span class="tt">PHYSICS_DOCS</span> dict at the top of the file:</p>
<div class="fragment"><div class="line">PHYSICS_DOCS = {</div>
<div class="line">    ...</div>
<div class="line">    <span class="stringliteral">&quot;check_my_feature&quot;</span>: {</div>
<div class="line">        <span class="stringliteral">&quot;title&quot;</span>: <span class="stringliteral">&quot;My Feature Constraint&quot;</span>,          <span class="comment"># Required: human-readable title</span></div>
<div class="line">        <span class="stringliteral">&quot;category&quot;</span>: <span class="stringliteral">&quot;Thermodynamic Constraints&quot;</span>,    <span class="comment"># Required: groups the constraint in docs</span></div>
<div class="line">        <span class="stringliteral">&quot;explanation&quot;</span>: <span class="stringliteral">&quot;Why this constraint exists.&quot;</span>, <span class="comment"># Required: plain English</span></div>
<div class="line">        <span class="stringliteral">&quot;math&quot;</span>: <span class="stringliteral">r&quot;\alpha &gt; 0&quot;</span>,                      <span class="comment"># Optional: LaTeX formula</span></div>
<div class="line">        <span class="stringliteral">&quot;references&quot;</span>: [<span class="stringliteral">&quot;Wilfong26&quot;</span>],                <span class="comment"># Optional: BibTeX keys from references.bib</span></div>
<div class="line">        <span class="stringliteral">&quot;exceptions&quot;</span>: [<span class="stringliteral">&quot;IBM cases&quot;</span>],                <span class="comment"># Optional: when constraint doesn&#39;t apply</span></div>
<div class="line">    },</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <a class="el" href="physics_constraints.html" title="Physics Constraints">Physics Constraints</a> page is <b>auto-generated</b> — run <span class="tt">./mfc.sh generate</span> to rebuild it. The generator merges your <span class="tt">PHYSICS_DOCS</span> entry with the AST-extracted <span class="tt">prohibit()</span>/<span class="tt">warn()</span> calls, so stage, severity, and parameter information appear automatically.</p>
<p><b>Fields:</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">title</span>  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">Section heading in generated docs  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">category</span>  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">Grouping category (e.g., "Mixture Constraints")  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">explanation</span>  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">Plain English description of the physics  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">math</span>  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">LaTeX formula (rendered by Doxygen's MathJax)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">references</span>  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">List of BibTeX cite keys from <span class="tt">docs/references.bib</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">exceptions</span>  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">List of cases where the constraint doesn't apply  </td></tr>
</table>
<p><b>Categories:</b> Thermodynamic Constraints, Mixture Constraints, Domain and Geometry, Velocity and Dimensional Consistency, Model Equations, Boundary Conditions, Bubble Physics, Feature Compatibility, Numerical Schemes, Acoustic Sources, Post-Processing.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md98"></a>
Testing</h2>
<p>MFC has 500+ regression tests. See <a class="el" href="testing.html" title="Testing">Testing</a> for the full guide.</p>
<ul>
<li><b>Add tests</b> for any new feature or bug fix</li>
<li>Use <span class="tt">./mfc.sh test --generate</span> to create golden files for new cases</li>
<li>Keep tests fast: use small grids and short runtimes</li>
<li>Test with <span class="tt">-a</span> to include post-processing validation</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md99"></a>
CI Pipeline</h2>
<p>Every push to a PR triggers CI. Understanding the pipeline helps you fix failures quickly.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md100"></a>
Lint Gate (runs first, blocks all other jobs)</h3>
<p>All four checks must pass before any builds start:</p>
<ol type="1">
<li><b>Formatting</b> — <span class="tt">./mfc.sh format</span> (auto-handled by pre-commit hook)</li>
<li><b>Spelling</b> — <span class="tt">./mfc.sh spelling</span></li>
<li><b>Toolchain lint</b> — <span class="tt">./mfc.sh lint</span> (Python code quality)</li>
<li><b>Source lint</b> — checks for:<ul>
<li>Raw <span class="tt">!$acc</span> or <span class="tt">!$omp</span> directives (must use Fypp GPU macros)</li>
<li>Double-precision intrinsics (<span class="tt">dsqrt</span>, <span class="tt">dexp</span>, <span class="tt">dble</span>, etc.)</li>
</ul>
</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md101"></a>
Build and Test Matrix</h3>
<p>After the lint gate passes:</p>
<ul>
<li><b>Platforms:</b> Ubuntu and macOS</li>
<li><b>Compilers:</b> GNU (both), Intel OneAPI (Ubuntu only)</li>
<li><b>Modes:</b> debug + release, MPI + no-MPI, double + single precision</li>
<li><b>HPC runners:</b> Phoenix (NVIDIA/nvfortran), Frontier (AMD/Cray ftn) — both OpenACC and OpenMP backends</li>
<li><b>Retries:</b> Tests retry up to 3 times before failing</li>
<li><b>Cleanliness check:</b> Compiler warnings are tracked — your PR cannot increase the warning count</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md102"></a>
Common CI Failures</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Failure  </th><th class="markdownTableHeadNone">Fix  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Formatting check  </td><td class="markdownTableBodyNone">Pre-commit hook handles this; if you bypassed it, run <span class="tt">./mfc.sh format</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Raw pragma detected  </td><td class="markdownTableBodyNone">Replace <span class="tt">!$acc</span>/<span class="tt">!$omp</span> with Fypp GPU macros (see <a class="el" href="gpuParallelization.html" title="GPU Parallelization">GPU Parallelization</a>)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Double-precision intrinsic  </td><td class="markdownTableBodyNone">Use generic intrinsic with <span class="tt">wp</span> kind (e.g., <span class="tt">sqrt</span> not <span class="tt">dsqrt</span>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Golden file mismatch  </td><td class="markdownTableBodyNone">If intentional: <span class="tt">./mfc.sh test --generate --only &lt;UUID&gt;</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Warnings increased  </td><td class="markdownTableBodyNone">Fix the new compiler warnings before merging  </td></tr>
</table>
<p>See <a class="el" href="troubleshooting.html" title="Troubleshooting Guide">Troubleshooting Guide</a> for detailed debugging workflows.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md103"></a>
Documentation</h2>
<ul>
<li>Add or update <b>Doxygen docstrings</b> in source files for new public routines</li>
<li>Update <b>markdown docs</b> under <span class="tt">docs/</span> if user-facing behavior changes</li>
<li>Provide a minimal <b>example case</b> in <span class="tt">examples/</span> for new features when practical</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md104"></a>
Submitting a Pull Request</h2>
<ol type="1">
<li><b>PRs come from your fork.</b> Do not create branches on <span class="tt">MFlowCode/MFC</span> directly. Push to your fork and open a PR from there against <span class="tt">MFlowCode/MFC:master</span>.</li>
<li><b>One PR = one logical change.</b> Split large changes into focused PRs.</li>
<li><b>Fill out the PR template.</b> Remove checklist items that don't apply.</li>
<li><b>Link issues</b> with <span class="tt">Fixes #&lt;id&gt;</span> or <span class="tt">Part of #&lt;id&gt;</span>.</li>
<li><b>Ensure CI passes</b> before requesting review. Run <span class="tt">./mfc.sh test</span> locally first. Formatting and linting are handled automatically by the pre-commit hook.</li>
<li><b>Describe your testing</b>: what you ran, which compilers/platforms you used.</li>
</ol>
<p>If your change touches GPU code (<span class="tt">src/simulation/</span>), see the GPU checklist in the PR template.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md105"></a>
Code Review and Merge</h2>
<ul>
<li>Respond to reviewer comments promptly</li>
<li>Push focused updates; each push re-runs CI, so batch your fixes</li>
<li>A maintainer will merge your PR once all reviews are approved and CI is green</li>
</ul>
<p>If your PR is large or architectural, consider opening an issue first to discuss the approach. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
